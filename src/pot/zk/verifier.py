"""
Python interface for the Rust ZK verifier for SGD step verification.
"""

import json
import subprocess
import base64
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass

# Import ZK types
try:
    from .zk_types import SGDStepStatement
except ImportError:
    from zk_types import SGDStepStatement


@dataclass
class VerifierConfig:
    """Configuration for the ZK verifier."""
    params_k: int = 17
    rust_binary: Optional[Path] = None
    timeout: int = 60  # 1 minute (verification is faster than proving)


class SGDZKVerifier:
    """Zero-knowledge verifier for SGD training steps."""
    
    def __init__(self, config: Optional[VerifierConfig] = None):
        """Initialize the verifier with configuration."""
        self.config = config or VerifierConfig()
        
        # Find the Rust binary
        if self.config.rust_binary is None:
            # Try to find the binary in the expected location
            binary_path = Path(__file__).parent / "prover_halo2/target/release/verify_sgd_stdin"
            if not binary_path.exists():
                # Try debug build
                binary_path = Path(__file__).parent / "prover_halo2/target/debug/verify_sgd_stdin"
            
            if not binary_path.exists():
                raise FileNotFoundError(
                    f"Rust verifier binary not found. Please build it with:\n"
                    f"cd {Path(__file__).parent / 'prover_halo2'} && cargo build --release --bin verify_sgd_stdin"
                )
            
            self.config.rust_binary = binary_path
    
    def verify_sgd_step(self, 
                       statement: SGDStepStatement, 
                       proof: bytes) -> bool:
        """
        Verify a zero-knowledge proof for an SGD training step.
        
        Args:
            statement: Public statement about the SGD step
            proof: Proof bytes generated by the prover
            
        Returns:
            True if the proof is valid, False otherwise
        """
        # Convert statement to the format expected by Rust
        public_inputs = self._statement_to_public_inputs(statement)
        
        # Encode proof as base64
        proof_base64 = base64.b64encode(proof).decode('utf-8')
        
        # Create request for Rust binary
        request = {
            "public_inputs": public_inputs,
            "proof": proof_base64,
            "params_k": self.config.params_k
        }
        
        # Call Rust binary via subprocess
        try:
            result = subprocess.run(
                [str(self.config.rust_binary)],
                input=json.dumps(request),
                capture_output=True,
                text=True,
                timeout=self.config.timeout
            )
            
            # Exit code 0 means verification succeeded
            if result.returncode == 0:
                return True
            elif result.returncode == 1:
                # Verification failed (but no error in the process)
                return False
            else:
                # Unexpected error
                raise RuntimeError(f"Verifier error: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            raise TimeoutError(f"Verification timed out after {self.config.timeout} seconds")
        except Exception as e:
            raise RuntimeError(f"Verification failed: {e}")
    
    def _statement_to_public_inputs(self, stmt: SGDStepStatement) -> Dict[str, Any]:
        """Convert SGDStepStatement to Rust public inputs format."""
        return {
            "w_t_root": self._bytes_to_hex(stmt.W_t_root),
            "batch_root": self._bytes_to_hex(stmt.batch_root),
            "hparams_hash": self._bytes_to_hex(stmt.hparams_hash),
            "w_t1_root": self._bytes_to_hex(stmt.W_t1_root),
            "step_nonce": stmt.step_nonce,
            "step_number": stmt.step_number,
            "epoch": stmt.epoch
        }
    
    def _bytes_to_hex(self, data: bytes) -> str:
        """Convert bytes to hex string with 0x prefix."""
        if isinstance(data, bytes):
            # Ensure we have exactly 32 bytes for field elements
            if len(data) < 32:
                data = data + b'\x00' * (32 - len(data))
            elif len(data) > 32:
                data = data[:32]
            return "0x" + data.hex()
        elif isinstance(data, str):
            if data.startswith("0x"):
                # Ensure even length
                hex_part = data[2:]
                if len(hex_part) % 2 == 1:
                    hex_part = "0" + hex_part
                # Pad to 64 hex chars (32 bytes)
                if len(hex_part) < 64:
                    hex_part = hex_part + "0" * (64 - len(hex_part))
                return "0x" + hex_part
            return "0x" + data
        else:
            # Assume it's a hash-like object
            hex_str = str(data)
            if not hex_str.startswith("0x"):
                hex_str = "0x" + hex_str
            # Ensure even length and padding
            hex_part = hex_str[2:]
            if len(hex_part) % 2 == 1:
                hex_part = "0" + hex_part
            if len(hex_part) < 64:
                hex_part = hex_part + "0" * (64 - len(hex_part))
            return "0x" + hex_part


# Convenience function for simple usage
def verify_sgd_step(statement: SGDStepStatement, 
                   proof: bytes,
                   config: Optional[VerifierConfig] = None) -> bool:
    """
    Verify a zero-knowledge proof for an SGD training step.
    
    Args:
        statement: Public statement about the SGD step
        proof: Proof bytes generated by the prover
        config: Optional verifier configuration
        
    Returns:
        True if the proof is valid, False otherwise
    """
    verifier = SGDZKVerifier(config)
    return verifier.verify_sgd_step(statement, proof)